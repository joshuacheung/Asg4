#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(strftime);


my @inputs;
my %graph;
my %comgraph;
my @commands;
my @target;
my $tar;
my $com;
my %macros;
my @orderarray;
my $macroKey;
my $value;


my $makefile = "Makefile";
open my $fh, '<', $makefile or die "Cannot open file : $_"; #file handler
use Data::Dumper;

for my $input (@inputs) {

  my $firstChar = substr $input, 0, 1;
  #if line has equals in it and does not start with a tab then
  #it is assigning macros.
  if ($input =~ /\s=\s/ && $firstChar ne "\t"){
    chomp $input;
    ($macroKey, $value) = split /\s+=\s+/, $input;
    $macros{$macroKey} = $value;
    push(@orderarray, $macroKey);
    print "\$key: $macroKey\n";
    print "value: $value\n";
    print "\n";

    #changes all macros to their definitions, in order of declaration
    for my $nextinput (@inputs){
      $nextinput =~ s/\${$macroKey}/$value/g;
    }
  }
}

while(my $line = <$fh>){
  chomp $line; #gets rid of whitespace
  push(@inputs, $line);
}

sub parse_dep ($) {
   my ($line) = @_;
    return undef unless $line =~ m/^(\S+)\s*:\s*(.*?)\s*$/;
    my ($target, $dependency) = ($1, $2);
    my @dependencies = split m/\s+/, $dependency;
    return $target, \@dependencies;
}

sub mtime ($) {
   my ($filename) = @_;
   my @stat = stat $filename;
   return @stat ? $stat[9] : undef;
}

sub fileinfo ($) {
   my ($filename) = @_;
   my $mtime = mtime $filename;
   print "$filename: ";
   if (defined $mtime) {print strftime "%c\n", localtime $mtime}
                  else {print "$!\n"}
   return $mtime;
}
sub runCommand($){
  my @key = @_;
  foreach my $key (@key){
    my @coms = @{$comgraph{$key}};
    foreach my $comkey (@coms){
      my $string = $comkey;
      my $firstchar = substr($string, 0,1);
      if($firstchar =~ "@"){
         system (substr($string, 1));
     }else{
         print "$comkey\n";
         system ($comkey);
     }
    }

  }
}

sub make {
  my($key,@deps) = @_;
  my $obs = 0;
  @target = grep {!/$key/} @target;
  if (scalar @deps >0){
    foreach my $deps (@deps){
      if(exists $graph{$deps}){
        my @subdep = @{$graph{$deps}};
        make(@subdep,$deps);
        $obs = 1;
      }elsif(-e $deps){
        if(-e $key){
          my $tartime = mtime $key;
          my $pretime = mtime $deps;
          if($tartime<$pretime){
            $obs = 1;
          }
        }else{
          $obs = 1;
        }
      }else{
        print "prerequisite does not exist\n";
        exit 1;
      }
    }
    if($obs =~ 1){
      runCommand $key;
    }
  }else{
    runCommand $key;
  }
}

for my $input (@inputs) {
  my ($target, $deps) = parse_dep $input;
  if(defined $target){
      $graph{$target} = $deps;
      $tar = $target;
      push @target, $target;
    }else{
      if($input=~ "\t"){
        $input =~ s/\t|\n//g;
        $com = $input;
        push @{$comgraph{$tar}} , $com;
      }
    }
}

#if '@' in command then remove and call system,
#else print command and call system
foreach my $key (@target){
  my @deps = @{$graph{$key}};
  make ($key,@deps);
}
